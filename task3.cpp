#include <iostream>  // подключаем библиотеку для ввода-вывода
#define MAX 20        // максимальное количество процессов и ресурсов
using namespace std; // используем стандартное пространство имен

// Объявляем класс "bankers"
class bankers
{
    private:
        int al[MAX][MAX], m[MAX][MAX], n[MAX][MAX], avail[MAX]; // матрицы для аллоцированных ресурсов, максимальных потребностей, оставшихся потребностей и доступных ресурсов
        int nop, nor, k, result[MAX], pnum, work[MAX], finish[MAX]; // количество процессов, ресурсов, индекс текущего ресурса, результат и массивы для работы

    public:
        bankers(); // конструктор класса
        void input(); // метод для ввода данных
        void method(); // метод для применения алгоритма банкира
        int search(int); // метод для поиска процесса, который может быть завершен
        void display(); // метод для отображения результатов
};

// Конструктор класса, инициализация всех массивов значениями по умолчанию
bankers::bankers()
{
    k = 0; // индекс результата
    for (int i = 0; i < MAX; i++)  // обнуляем все массивы
    {
        for (int j = 0; j < MAX; j++)
        {
            al[i][j] = 0; // аллоцированные ресурсы
            m[i][j] = 0;  // максимальные ресурсы
            n[i][j] = 0;  // оставшиеся потребности
        }
        avail[i] = 0; // доступные ресурсы
        result[i] = 0; // результат
        finish[i] = 0; // финишные индикаторы
    }
}

// Метод для ввода данных
void bankers::input()
{
    int i, j;
    cout << "Введите количество процессов: "; // запрос количества процессов
    cin >> nop;
    cout << "Введите количество ресурсов: "; // запрос количества типов ресурсов
    cin >> nor;
    
    cout << "Введите аллоцированные ресурсы для каждого процесса: \n";
    // Вводим аллоцированные ресурсы для каждого процесса
    for (i = 0; i < nop; i++)
    {
        cout << "\nПроцесс " << i; // выводим номер процесса
        for (j = 0; j < nor; j++)
        {
            cout << "\nРесурс " << j << ": "; // запрос аллоцированного ресурса
            cin >> al[i][j];
        }
    }

    cout << "Введите максимальные ресурсы, которые необходимы для каждого процесса: \n";
    // Вводим максимальные потребности для каждого процесса
    for (i = 0; i < nop; i++)
    {
        cout << "\nПроцесс " << i; // выводим номер процесса
        for (j = 0; j < nor; j++)
        {
            cout << "\nРесурс " << j << ": "; // запрос максимальных потребностей
            cin >> m[i][j];
            n[i][j] = m[i][j] - al[i][j]; // вычисляем оставшиеся потребности
        }
    }

    cout << "Введите доступные ресурсы в системе: "; 
    // Вводим доступные ресурсы
    for (j = 0; j < nor; j++)
    {
        cout << "Ресурс " << j << ": "; 
        cin >> avail[j];
        work[j] = -1; // инициализируем массив work значением -1
    }

    // Инициализация массива finish
    for (i = 0; i < nop; i++)
        finish[i] = 0;
}

// Основной метод, реализующий алгоритм банкира
void bankers::method()
{
    int i = 0, j, flag;
    while (1)
    {
        if (finish[i] == 0) // если процесс не завершен
        {
            pnum = search(i); // ищем процесс, который можно завершить
            if (pnum != -1) // если такой процесс найден
            {
                result[k++] = i; // добавляем его в результат
                finish[i] = 1; // процесс завершен
                for (j = 0; j < nor; j++) 
                {
                    avail[j] = avail[j] + al[i][j]; // возвращаем ресурсы обратно
                }
            }
        }
        i++;
        if (i == nop) // если все процессы были проверены
        {
            flag = 0;
            for (j = 0; j < nor; j++)
                if (avail[j] != work[j]) // если ресурсы изменились
                    flag = 1;
            for (j = 0; j < nor; j++)
                work[j] = avail[j]; // обновляем массив work

            if (flag == 0) // если не было изменений, выходим из цикла
                break;
            else
                i = 0; // иначе начинаем проверку с первого процесса
        }
    }
}

// Метод поиска процесса, который может быть завершен
int bankers::search(int i)
{
    int j;
    for (j = 0; j < nor; j++)
        if (n[i][j] > avail[j]) // если оставшиеся потребности больше доступных ресурсов
            return -1; // процесс не может быть завершен
    return 0; // процесс может быть завершен
}

// Метод для отображения результатов
void bankers::display()
{
    int i, j;
    cout << endl << "РЕЗУЛЬТАТ:";
    cout << endl << "=========";
    cout << endl << "PROCESS\t     ALLOCATED\t     MAXIMUM\t     NEED";
    // Выводим таблицу с данными процессов
    for (i = 0; i < nop; i++)
    {
        cout << "\nP" << i + 1 << "\t     ";
        for (j = 0; j < nor; j++)
        {
            cout << al[i][j] << "  "; // выводим аллоцированные ресурсы
        }
        cout << "\t     ";
        for (j = 0; j < nor; j++)
        {
            cout << m[i][j] << "  "; // выводим максимальные ресурсы
        }
        cout << "\t     ";
        for (j = 0; j < nor; j++)
        {
            cout << n[i][j] << "  "; // выводим оставшиеся потребности
        }
    }

    cout << "\nПоследовательность безопасных процессов: \n";
    for (i = 0; i < k; i++)
    {
        int temp = result[i] + 1; 
        cout << "P" << temp << " "; // выводим безопасную последовательность
    }

    cout << "\nПоследовательность небезопасных процессов: \n";
    int flg = 0;
    for (i = 0; i < nop; i++)
    {
        if (finish[i] == 0)
        {
            flg = 1;
        }
        cout << "P" << i << " "; // выводим небезопасные процессы
    }
    cout << endl << "РЕЗУЛЬТАТ:";
    cout << endl << "=======";
    if (flg == 1)
        cout << endl << "Система не находится в безопасном состоянии, и может произойти дедлок!!";
    else
        cout << endl << "Система находится в безопасном состоянии, дедлок не произойдет!!";
}

// Главная функция, которая запускает программу
int main()
{
    cout << "АЛГОРИТМ БАНКИРА ПО УПРАВЛЕНИЮ РЕСУРСАМИ" << endl;
    bankers B; // создаем объект класса bankers
    B.input();  // ввод данных
    B.method(); // выполнение алгоритма
    B.display(); // отображение результатов
}